
    /// <summary>
    /// Invokes a single JSON-RPC request with transport filtering.
    /// Returns null for notifications (no response expected).
    /// </summary>
    private async Task<object?> InvokeSingleAsync(
        JsonElement element,
        CancellationToken cancellationToken,
        string transport)
    {
        object? id = null;
        
        try
        {
            // Parse JSON-RPC message
            if (!JsonRpcMessage.TryGetFromJsonElement(element, out var message) || message is null)
            {
                return ToolResponse.Error(
                    null,
                    -32600,
                    "Invalid Request",
                    "Must be valid JSON-RPC 2.0 message");
            }

            id = message.Id;

            // Only process requests and notifications
            if (!message.IsRequest && !message.IsNotification)
            {
                return ToolResponse.Error(
                    id,
                    -32600,
                    "Invalid Request",
                    "Message must be a request or notification");
            }

            // MCP protocol methods (check BEFORE GetToolDetails!)
            if (message.Method == "initialize")
            {
                return HandleInitialize(message);
            }
            
            if (message.Method == "tools/list")
            {
                // Use transport-aware filtering
                return HandleToolsList(message, transport);
            }
            
            if (message.Method == "tools/call")
            {
                return await HandleToolsCallAsync(message, cancellationToken);
            }

            // MCP notifications (client â†’ server, no response expected)
            if (message.Method?.StartsWith("notifications/") == true)
            {
                // Log and ignore MCP notifications (e.g., "notifications/initialized")
                _logger.LogInformation("Received MCP notification: {Method}", message.Method);
                return null; // No response for notifications
            }

            // Get tool details
            var toolDetails = _toolService.GetToolDetails(message.Method);
            
            // Check if this is a ToolConnector-based tool (streaming)
            if (toolDetails.ToolArgumentType.IsToolConnector)
            {
                // ToolConnector tools should be initiated via StreamMessage start, not JSON-RPC
                return ToolResponse.Error(
                    id,
                    -32601,
                    "Use StreamMessage to initiate streaming",
                    "Send a StreamMessage with type='start' to begin streaming");
            }
            
            // Build arguments for tool method
            object[] args = [message];

            // Invoke the tool
            var result = _toolService.InvokeToolDelegate(
                message.Method,
                toolDetails,
                args);

            // Handle different return types
            return await ProcessToolResultAsync(result, toolDetails, message.IsNotification, id, cancellationToken);
        }
        catch (ToolNotFoundException ex)
        {
            _logger.LogWarning(ex, "Tool not found: {Method}", ex.Message);
            return ToolResponse.Error(id, -32601, "Method not found", new { detail = ex.Message });
        }
        catch (ToolInvalidParamsException ex)
        {
            _logger.LogWarning(ex, "Invalid params for tool");
            return ToolResponse.Error(id, -32602, "Invalid params", new { detail = ex.Message });
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error invoking tool");
            return ToolResponse.Error(id, -32603, "Internal error", new { detail = ex.Message });
        }
    }

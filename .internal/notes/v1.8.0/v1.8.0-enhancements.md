# üöÄ MCP Gateway v1.8.0 - Enhancement Roadmap

**Created:** 19. desember 2025  
**Branch:** feat/v1.8.0-enhancements  
**Target:** Future enhancements beyond MCP 2025-11-25 compliance  
**Current Version:** v1.7.0 (MCP 2025-11-25 - 100% compliant)  
**Target Version:** v1.8.0  
**Status:** Planning & Ideation

---

## üìä Executive Summary

With **v1.7.0 achieving 100% MCP 2025-11-25 compliance**, v1.8.0 focuses on:
- üîç **Quality of life improvements**
- üöÄ **Performance optimizations**
- üìö **Enhanced developer experience**
- üéØ **Optional MCP 2025-11-25 extensions**

**Philosophy:** No rush - focus on stability, community feedback, and incremental value.

---

## üéØ Potential Enhancements (Not Prioritized)

### Category 1: MCP Protocol Extensions (Optional)

These are **optional** MCP 2025-11-25 features, not required for compliance:

#### 1.1 Resource Subscriptions
**MCP Spec:** Optional `resources/subscribe` and `resources/unsubscribe` methods

```csharp
// Client subscribes to resource changes (exact URI only per MCP spec)
{
  "jsonrpc": "2.0",
  "method": "resources/subscribe",
  "params": {
    "uri": "file://logs/app.log"  // Exact match only in v1.8.0
  },
  "id": 1
}

// Server sends notification when resource changes
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file://logs/app.log"
  }
}
```

**Benefits:**
- Clients can subscribe to specific resources instead of receiving all notifications
- Reduces unnecessary notifications
- Better for high-frequency resource updates

**Implementation approach (v1.8.0):**
- Start with exact URI matching only (per MCP 2025-11-25 spec)
- No wildcard support in initial version
- Simpler implementation, clearer semantics
- Can add wildcards as extension in v1.9.0 if needed

**Potential v1.9.0 extensions (based on community feedback):**
- Wildcard patterns: `file://logs/*.log`, `file://logs/**`
- Regex matching: `file://logs/app-[0-9]+.log`
- Prefix matching: `file://logs/` (all resources under path)

**Estimated effort:** 8-12 hours (implement + test, exact matching only)

---

#### 1.2 Resource Templates
**MCP Spec:** URI templates with variables (e.g., `file://logs/{date}.log`)

```csharp
[McpResource("file://logs/{date}.log",
    Name = "Daily Log Files",
    Description = "Log files by date (format: YYYY-MM-DD)")]
public JsonRpcMessage GetLogFile(JsonRpcMessage request)
{
    var uri = request.GetParams().GetProperty("uri").GetString();
    var date = ExtractDateFromUri(uri); // Parse {date} variable
    
    var content = ReadLogFile(date);
    return ToolResponse.Success(request.Id, new ResourceContent(
        Uri: uri,
        MimeType: "text/plain",
        Text: content
    ));
}
```

**Benefits:**
- Dynamic resource generation
- Less boilerplate for parameterized resources
- Better for large resource sets

**Estimated effort:** 12-16 hours (design + implement + test)

---

#### 1.3 Completion API
**MCP Spec:** Optional `completion/complete` method for auto-completion

```csharp
// Client requests completions
{
  "jsonrpc": "2.0",
  "method": "completion/complete",
  "params": {
    "ref": {
      "type": "ref/prompt",
      "name": "summarize"
    },
    "argument": {
      "name": "topic",
      "value": "mach"
    }
  },
  "id": 1
}

// Server returns completions
{
  "jsonrpc": "2.0",
  "result": {
    "completion": {
      "values": ["machine learning", "machine vision", "Mach number"],
      "total": 3,
      "hasMore": false
    }
  },
  "id": 1
}
```

**Benefits:**
- Better UX for prompts with many arguments
- IDE-like auto-completion in MCP clients
- Type-ahead search for resources

**Estimated effort:** 16-20 hours (design + implement + test)

---

#### 1.4 Logging Support
**MCP Spec:** Optional client-to-server log forwarding

```csharp
// Client sets log level
{
  "jsonrpc": "2.0",
  "method": "logging/setLevel",
  "params": {
    "level": "debug"
  }
}

// Server sends log messages
{
  "jsonrpc": "2.0",
  "method": "notifications/message",
  "params": {
    "level": "info",
    "logger": "ToolInvoker",
    "data": "Tool 'add_numbers' executed successfully"
  }
}
```

**Benefits:**
- Unified logging across client-server boundary
- Better debugging for MCP integrations
- Centralized log collection

**Estimated effort:** 12-16 hours (design + implement + test)

---

### Category 2: Performance Optimizations

#### 2.1 Parameter Parsing Cache
**Goal:** Cache parsed tool parameters to avoid repeated JSON deserialization

**Current:**
```csharp
// Every tool call parses params from scratch
var args = request.GetParams<AddNumbersRequest>();
```

**Proposed:**
```csharp
// Cache parsed params per request ID
var args = request.GetCachedParams<AddNumbersRequest>();
```

**Benefits:**
- Faster tool invocation (especially for streaming tools)
- Less GC pressure
- Better for high-throughput scenarios

**Trade-offs:**
- Added complexity
- Memory overhead for caching
- May not provide significant benefit for simple tools

**Estimated effort:** 8-12 hours (implement + benchmark + test)  
**Priority:** LOW (optimize only if bottleneck confirmed)

---

#### 2.2 Connection Pooling
**Goal:** Reuse HTTP/WebSocket connections for repeated tool calls

**Benefits:**
- Reduced connection overhead
- Better for client libraries making many requests
- Lower latency for subsequent calls

**Trade-offs:**
- Already handled by HttpClient in most cases
- May not provide significant benefit

**Estimated effort:** 12-16 hours (design + implement + test)  
**Priority:** LOW (measure first)

---

#### 2.3 Streaming Optimizations
**Goal:** Reduce allocations and improve throughput for binary/text streaming

**Ideas:**
- Use `Span<T>` and `Memory<T>` for zero-copy operations
- Pipeline-based streaming (System.IO.Pipelines)
- Chunked encoding optimizations

**Benefits:**
- Lower memory usage
- Higher throughput for large files
- Better for media streaming scenarios

**Estimated effort:** 20-30 hours (design + implement + benchmark + test)  
**Priority:** MEDIUM (if streaming becomes a bottleneck)

---

### Category 3: Developer Experience

#### 3.1 TypedJsonRpc<T> Already Has Raw JSON Access! ‚úÖ

**Note:** `TypedJsonRpc<T>` already provides access to raw `JsonRpcMessage` via the `.Inner` property:

```csharp
[McpTool("add_numbers")]
public JsonRpcMessage AddNumbers(
    TypedJsonRpc<AddNumbersRequest> request,
    ILogger<CalculatorTools> logger)
{
    // Typed access
    var args = request.GetParams();
    
    // Raw JSON access via Inner property!
    logger.LogInformation("Raw JSON: {Raw}", request.Inner.ToJson());
    logger.LogInformation("Method: {Method}", request.Inner.Method);
    logger.LogInformation("ID: {Id}", request.Inner.Id);
    
    return ToolResponse.Success(request.Id, new { result = args.Number1 + args.Number2 });
}
```

**Conclusion:** No need for a separate Hybrid Tool API - `TypedJsonRpc<T>` already provides the best of both worlds!

**Status:** ‚úÖ **NOT NEEDED** (already implemented in v1.3.0)

---

#### 3.2 Tool Lifecycle Hooks
**Goal:** Add hooks for monitoring and metrics

**Proposed:**
```csharp
public interface IToolLifecycleHook
{
    Task OnToolInvoked(string toolName, JsonRpcMessage request);
    Task OnToolCompleted(string toolName, JsonRpcMessage response, TimeSpan duration);
    Task OnToolFailed(string toolName, Exception error);
}

// Register in DI
builder.Services.AddSingleton<IToolLifecycleHook, MetricsHook>();
```

**Benefits:**
- Easy integration with metrics systems (Prometheus, Application Insights)
- Audit trail for tool invocations
- Performance monitoring

**Estimated effort:** 12-16 hours (design + implement + test)  
**Priority:** MEDIUM (useful for production monitoring)

---

#### 3.3 Custom Transport Providers
**Goal:** Pluggable transport system for custom protocols

**Proposed:**
```csharp
public interface ITransportProvider
{
    Task<JsonRpcMessage> ReceiveAsync(CancellationToken ct);
    Task SendAsync(JsonRpcMessage message, CancellationToken ct);
}

// Custom transport
public class GrpcTransportProvider : ITransportProvider { ... }

// Register
builder.AddToolsService()
    .WithTransport<GrpcTransportProvider>();
```

**Benefits:**
- Support for gRPC, SignalR, custom protocols
- Extensibility without modifying core library
- Community can add transports

**Trade-offs:**
- Significant architecture changes
- May not be needed (current transports cover most use cases)

**Estimated effort:** 30-40 hours (design + implement + test)  
**Priority:** LOW (no clear demand yet)

---

#### 3.4 Enhanced Streaming
**Goal:** Add compression, flow control, and multiplexing to streaming

**Ideas:**
- Compression: gzip/brotli for text streams
- Flow control: Backpressure handling
- Multiplexing: Multiple streams per connection

**Benefits:**
- Better bandwidth utilization
- Support for slow clients
- More efficient connection usage

**Trade-offs:**
- Complexity
- May break compatibility with existing clients

**Estimated effort:** 40-60 hours (major feature)  
**Priority:** LOW (current streaming works well)

---

### Category 4: Quality of Life

#### 4.1 Better Error Messages
**Goal:** More descriptive error messages for common mistakes

**Examples:**
- Tool not found ‚Üí suggest similar tool names
- Invalid parameters ‚Üí show expected schema
- Session expired ‚Üí suggest re-initialization

**Estimated effort:** 4-8 hours (implement + test)  
**Priority:** MEDIUM (improves developer experience)

---

#### 4.2 Health Check Improvements
**Goal:** More detailed health checks for production monitoring

**Proposed:**
```json
{
  "status": "healthy",
  "uptime": "2h 15m",
  "tools": 42,
  "prompts": 5,
  "resources": 12,
  "sessions": 3,
  "notifications": {
    "sseStreams": 3,
    "wsConnections": 0
  },
  "version": "1.8.0",
  "protocolVersion": "2025-11-25"
}
```

**Estimated effort:** 4-6 hours (implement + test)  
**Priority:** LOW (current health check is adequate)

---

#### 4.3 Example Updates
**Goal:** Update examples to showcase v1.7.0 features

**Tasks:**
- Update all examples to use `/mcp` endpoint
- Add session management examples
- Add SSE notification examples
- Update documentation with v1.7.0 patterns

**Estimated effort:** 6-8 hours (update + test + docs)  
**Priority:** HIGH (should be done soon after v1.7.0)

---

## üìä Prioritization Framework

### Must-Have (v1.8.0)
- ‚úÖ Example updates (HIGH priority)
- ‚úÖ Better error messages (MEDIUM priority)

### Should-Have (v1.8.0 or v1.9.0)
- Tool lifecycle hooks (monitoring)
- Resource subscriptions (optional MCP feature)

### Nice-to-Have (v2.0+)
- Resource templates
- Completion API
- Logging support
- ~~Hybrid Tool API~~ (NOT NEEDED - `TypedJsonRpc<T>.Inner` already exists!)
- Performance optimizations (only if bottlenecks confirmed)

### Future Consideration
- Custom transport providers
- Enhanced streaming
- Connection pooling

---

## üéØ Proposed v1.8.0 Scope

**Goal:** Small, focused release with high-value improvements

**Included:**
1. ‚úÖ Update all examples to v1.7.0 patterns (6-8h)
2. ‚úÖ Better error messages (4-8h)
3. ‚úÖ Tool lifecycle hooks for monitoring (12-16h)
4. ‚úÖ Resource subscriptions (8-12h)

**Total estimated:** ~30-44 hours (~1 week of focused work)

**Excluded (defer to v1.9.0 or v2.0):**
- Resource templates (needs more design)
- Completion API (low demand)
- Logging support (can wait)
- Performance optimizations (no confirmed bottlenecks)
- ~~Hybrid Tool API~~ (NOT NEEDED - `TypedJsonRpc<T>.Inner` already exists!)
- Custom transports (no clear use case yet)

---

## üöÄ Implementation Strategy

### Phase 1: Examples & Documentation (Quick Wins)
**Goal:** Showcase v1.7.0 features, help users migrate

**Tasks:**
1. Update `Examples/CalculatorMcpServer` to use `/mcp` endpoint
2. Update `Examples/DateTimeMcpServer` to use `/mcp` endpoint
3. Update `Examples/PromptMcpServer` to use `/mcp` endpoint
4. Update `Examples/ResourceMcpServer` to use `/mcp` endpoint
5. Update `Examples/NotificationMcpServer` to show SSE notifications
6. Add session management example
7. Update documentation with migration guide

**Estimated time:** 6-8 hours  
**Priority:** HIGH  
**Can start:** Immediately

---

### Phase 2: Error Messages (Quality of Life)
**Goal:** Better DX with descriptive errors

**Tasks:**
1. Tool not found ‚Üí suggest similar names (Levenshtein distance)
2. Invalid params ‚Üí show expected schema with examples
3. Session expired ‚Üí clear re-initialization guidance
4. Protocol version mismatch ‚Üí show supported versions

**Estimated time:** 4-8 hours  
**Priority:** MEDIUM  
**Can start:** After Phase 1

---

### Phase 3: Tool Lifecycle Hooks (Monitoring)
**Goal:** Production-ready monitoring and metrics

**Tasks:**
1. Design `IToolLifecycleHook` interface
2. Implement hook invocation in `ToolInvoker`
3. Add metrics example (Prometheus/Application Insights)
4. Write tests
5. Update documentation

**Estimated time:** 12-16 hours  
**Priority:** MEDIUM  
**Can start:** After Phase 2

---

### Phase 4: Resource Subscriptions (Optional MCP)
**Goal:** Implement optional MCP 2025-11-25 feature

**Tasks:**
1. Design subscription storage (per-session)
2. Implement `resources/subscribe` handler
3. Implement `resources/unsubscribe` handler
4. Update notification logic to check subscriptions
5. Add tests
6. Update documentation

**Estimated time:** 8-12 hours  
**Priority:** MEDIUM  
**Can start:** After Phase 3

---

## üìä Timeline Estimate

| Phase | Duration | Deliverables | Status |
|-------|----------|--------------|--------|
| **Phase 1** | 6-8 hours | Updated examples + docs | üìù Planned |
| **Phase 2** | 4-8 hours | Better error messages | üìù Planned |
| **Phase 3** | 12-16 hours | Tool lifecycle hooks | üìù Planned |
| **Phase 4** | 8-12 hours | Resource subscriptions | üìù Planned |
| **Total** | **30-44 hours** | v1.8.0 Release | üìù Planned |

**Target:** ~1 week of focused work (not consecutive)

---

## üéñÔ∏è Success Criteria

### v1.8.0 Goals
- ‚úÖ All examples use v1.7.0 patterns (`/mcp` endpoint, SSE)
- ‚úÖ Better error messages for common mistakes
- ‚úÖ Tool lifecycle hooks for monitoring
- ‚úÖ Resource subscriptions (optional MCP feature)
- ‚úÖ All tests passing (253+ tests)
- ‚úÖ Zero breaking changes
- ‚úÖ Documentation updated

### Non-Goals (Deferred)
- ‚ùå Performance optimizations (no confirmed bottlenecks)
- ‚ùå Resource templates (needs more design)
- ‚ùå Completion API (low demand)
- ‚ùå Custom transport providers (no clear use case)
- ‚ùå Hybrid Tool API (NOT NEEDED - `TypedJsonRpc<T>.Inner` already provides raw JSON access!)

---

## üìö References

### Previous Planning Documents
- `.internal/notes/v1.7.0/omw-to-2025-11-25.md` - v1.7.0 roadmap
- `.internal/notes/v1.7.0/phase-1-streamable-http-design.md` - Phase 1 design
- `.internal/notes/v1.7.0/phase-2-sse-notifications-design.md` - Phase 2 design
- `.internal/notes/v1.2.0/HybridToolAPI-Plan.md` - Hybrid API (deferred)
- `.internal/notes/Performance-Optimization-Plan.md` - Performance ideas

### MCP Specification
- **MCP 2025-11-25:** https://modelcontextprotocol.io/specification/2025-11-25/
- **Optional Features:** Resource subscriptions, templates, completion, logging

---

## ü§î Open Questions

1. **Resource Subscriptions:** Do we need fine-grained subscriptions (per URI) or coarse-grained (all resources)?
2. **Lifecycle Hooks:** Should hooks be async or sync? What about error handling?
3. **Error Messages:** How much detail to include? Risk of leaking internal implementation?
4. **Monitoring:** What metrics are most valuable? (count, duration, success rate, etc.)
5. **Resource Subscription Wildcards (v1.8.0 vs v1.9.0):**
   - **MCP 2025-11-25 spec:** Only exact URI matching defined (e.g., `"uri": "file://logs/app.log"`)
   - **v1.8.0 approach:** Start with exact URI matching only (spec-compliant)
   - **v1.9.0 consideration:** Add wildcard support as extension if community requests it
   - **Wildcard examples:** `file://logs/*.log`, `file://logs/**`, `file://logs/app-*.log`
   - **Trade-offs:**
     - Pros: More flexible, fewer subscriptions needed, better for dynamic resources
     - Cons: More complex, potential security risks (over-broad subscriptions), can generate many notifications
   - **Decision:** Implement exact matching in v1.8.0, evaluate wildcards for v1.9.0 based on feedback
   

---

## üí¨ Community Feedback

**Before starting v1.8.0 implementation:**
- Get feedback on v1.7.0 (NuGet download stats, GitHub issues)
- Ask community about most-wanted features
- Validate priorities based on real-world usage

**Channels:**
- GitHub Discussions
- NuGet package statistics
- GitHub issues/PRs

---

## üöÄ Next Steps

### Immediate (Post-v1.7.0)
1. üîú Monitor v1.7.0 adoption (NuGet downloads, feedback)
2. üîú Gather community feedback on priorities
3. üîú Finalize v1.8.0 scope based on demand

### Short-term (When starting v1.8.0)
1. üîú Start with Phase 1 (examples + docs) - high value, low risk
2. üîú Validate priorities with community
3. üîú Adjust scope based on feedback

### Long-term (v2.0+)
1. üîú Consider major features (custom transports, etc.)
2. üîú Breaking changes (if any)
3. üîú Performance rewrites (if bottlenecks confirmed)

---

**Status:** üìù **PLANNING**  
**Current Version:** v1.7.0 (released to NuGet!)  
**Target Version:** v1.8.0  
**Timeline:** No rush - quality over speed  
**Philosophy:** Small, focused releases with high value

---

**Created by:** ARKo AS - AHelse Development Team  
**Last Updated:** 19. desember 2025, kl. 00:45  
**Version:** 1.0 (Initial Planning Document)

---

## üéâ Congratulations on v1.7.0!

v1.7.0 was an **incredible achievement** - 100% MCP 2025-11-25 compliance in ONE NIGHT!

v1.8.0 is about **incremental improvements**, not another big push. Take your time, gather feedback, and focus on what users actually need. üí™

**No rush - enjoy the success of v1.7.0 first!** üéä
